#!/usr/bin/perl
# Copyright CentralNic Group plc.
# This program is Free Software; you can use it and/or modify it under the same
# terms as Perl itself.
use Term::ReadLine;
use Net::EPP::Simple;
use Getopt::Long;
use Text::ParseWords;
use Pod::Usage;
use strict;

my $opt = {};
GetOptions($opt,
	'host=s',
	'user=s',
	'pass=s',
	'port=i',
	'timeout=i',
	'help',
	'exec=s',
);

my $handlers = {
	'timeout'	=> \&handle_timeout,
	'ssl'		=> \&handle_ssl,
	'host'		=> \&handle_host,
	'port'		=> \&handle_port,
	'credentials'	=> \&handle_credentials,
	'id'		=> \&handle_id,
	'pw'		=> \&handle_pw,
	'connect'	=> \&handle_connect,
	'login'		=> \&handle_login,
	'logout'	=> \&handle_logout,
	'hello'		=> \&handle_hello,
	'check'		=> \&handle_check,
	'info'		=> \&handle_info,
	'poll'		=> \&handle_poll,
	'help'		=> \&handle_help,
	'send'		=> \&handle_send,
	'BEGIN'		=> \&handle_begin,
	'exit'		=> \&handle_exit,
	'keepalive'	=> \&handle_keepalive,
	'transfer'	=> \&handle_transfer,
	'clone'		=> \&handle_clone,
	'delete'	=> \&handle_delete,
	'renew'		=> \&handle_renew,
	'create'	=> \&handle_create,
};

if ($opt->{'help'}) {
	execute_command('help USAGE');
	exit;
}

my $epp = Net::EPP::Simple->new(
	'host'		=> '',
	'connect'	=> undef,
	'debug'		=> ($opt->{'exec'} eq ''),
	'login'		=> undef,
	'reconnect'	=> 0,
);


note('Welcome to pepper!');

execute_command(sprintf('timeout %d',	$opt->{'timeout'}))	if ($opt->{'timeout'});
execute_command(sprintf('port %d',	$opt->{'port'}))	if ($opt->{'port'});
execute_command(sprintf('host %s',	$opt->{'host'}))	if ($opt->{'host'});
execute_command(sprintf('id %s',	$opt->{'user'}))	if ($opt->{'user'});
execute_command(sprintf('pw %s',	$opt->{'pass'}))	if ($opt->{'pass'});

execute_command('connect') if ($epp->{'host'} ne '');
execute_command('login') if ($epp->{'user'} ne '' && $epp->{'pass'} ne '');

if ($opt->{'exec'} ne '') {
	if (!$epp->{'authenticated'}) {
		fatal('not logged in');

	} else {
		$epp->{'debug'} = 1;
		execute_command($opt->{'exec'});
		$epp->{'debug'} = 0;
		exit;

	}
}

my $term = Term::ReadLine->new('pepper');
my $prompt = 'pepper> ';
my $out = $term->OUT || \*STDOUT;

while (my $command = $term->readline($prompt)) {
	$term->addhistory($command);
	execute_command($command);
}

$epp->logout if ($epp->{'connected'} && $epp->{'authenticated'});
$epp->disconnect if ($epp->{'connected'});

$epp->{'debug'} = 0;

note('bye!');

sub execute_command {
	my $line = shift;
	my @args = shellwords($line);
	my $command = shift(@args);

	if (!defined($handlers->{$command})) {
		error("Unknown command '$command'");

	} else {
		&{$handlers->{$command}}(@args);

	}
}

sub handle_timeout {
	$epp->{'timeout'} = int($_[0]);
	note("Timeout set to %ds", $_[0]);
	return 1;
}

sub handle_ssl {
	if ($_[0] eq 'on') {
		$epp->{'ssl'} = 1;
		note('SSL enabled');

	} elsif ($_[0] eq 'off') {
		$epp->{'ssl'} = undef;
		note('SSL disabled');

	} else {
		error("Invalid SSL mode '%s'", $_[0]);
		return undef;

	}
	return 1;
}

sub handle_host {
	$epp->{'host'} = $_[0];
	note("Host set to %s", $_[0]);
	return 1;
}

sub handle_port {
	$epp->{'port'} = int($_[0]);
	note("Port set to %d", $_[0]);
	return 1;
}

sub handle_connect {
	if ($epp->{'host'} eq '') {
		error('No host specified');
		return undef;

	} else {
		note('Connecting to %s', $epp->{'host'});
		return $epp->_connect(undef);

	}
}

sub handle_credentials {
	if ($_[0] eq '') {
		error('Missing client ID');
		return undef;

	} elsif ($_[1] eq '') {
		error('Missing password');
		return undef;

	} else {
		handle_id($_[0]);
		handle_pw($_[1]);
		return 1;

	}
}

sub handle_id {
	$epp->{'user'} = shift;
	note("User ID set to '%s'", $epp->{'user'});
}

sub handle_pw {
	$epp->{'pass'} = shift;
	note("Password set to '%s'", $epp->{'pass'});
}

sub handle_login {
	if ($epp->{'host'} eq '') {
		error('No host specified');
		return undef;

	} elsif ($epp->{'user'} eq '' || $epp->{'pass'} eq '') {
		error('No credentials specified');
		return undef;

	} elsif (!defined($epp->{'connected'})) {
		return handle_connect() && handle_login();

	} else {
		return $epp->_login;

	}
}

sub handle_logout {
	if (!defined($epp->{'authenticated'})) {
		error('Not logged in');
		return undef;

	} else {
		note('logging out');
		return $epp->logout;
	}
}

sub handle_hello {
	return $epp->ping;
}

sub handle_check {
	my ($type, $id) = @_;
	if ($type eq 'domain') {
		return $epp->check_domain($id);

	} elsif ($type eq 'host') {
		return $epp->check_host($id);

	} elsif ($type eq 'contact') {
		return $epp->check_contact($id);

	} else {
		error("Unsupported object type '$type'");
		return undef;

	}
}

sub handle_info {
	my ($type, $id) = @_;
	if ($type eq 'domain') {
		return $epp->domain_info($id);

	} elsif ($type eq 'host') {
		return $epp->host_info($id);

	} elsif ($type eq 'contact') {
		return $epp->contact_info($id);

	} else {
		error("Unsupported object type '$type'");
		return undef;

	}
}

sub handle_poll {
	my ($op, $id) = @_;
	if ($op eq 'req') {
		my $frame = Net::EPP::Frame::Command::Poll::Req->new;
		$epp->request($frame);

	} elsif ($op eq 'ack') {
		my $frame = Net::EPP::Frame::Command::Poll::Ack->new;
		$frame->setMsgID($id);
		$epp->request($frame);

	} else {
		error("Unsupported poll op '$op'");

	}
}

sub handle_send {
	$epp->request($_[0]);
}

sub handle_begin {
	my $buffer = '';
	while (my $line = <STDIN>) {
		if ($line =~ /^END/) {
			last;

		} else {
			$buffer .= $line;

		}
	}
	$epp->request($buffer);
}

sub handle_help {
	pod2usage(
		'-verbose'	=> 99,
		'-sections'	=> join('|', @_) || 'SYNTAX',
		'-exitval'	=> 'NOEXIT',
	);
}

sub handle_keepalive {
	$epp->{'keepalive'} = int(shift);
	alarm(0);
	if ($epp->{'keepalive'} < 1) {
		note('disabling keepalive');
		undef($SIG{'ALRM'});

	} else {
		note('setting keepalive interval to %ds', $epp->{'keepalive'});
		$SIG{'ALRM'} = sub {
			note('ping');
			my $was = $epp->{'debug'};
			$epp->ping if ($epp->{'connected'});
			$epp->{'debug'} = $was;
			alarm($epp->{'keepalive'});
		};
		alarm($epp->{'keepalive'});
	}
}

sub handle_exit {
	$epp->logout if ($epp->{'authenticated'});
	$epp->disconnect if ($epp->{'connected'});
	note('bye!');
	$epp->{'debug'} = 0;
	exit;
}

sub handle_transfer {
	my ($type, $object, $cmd, $authinfo, $period) = @_;

	return error("invalid object type '%s'", $type) if ($type ne 'domain' && $type ne 'contact');
	return error("invalid command '%s'", $cmd) if ($cmd ne 'query' && $cmd ne 'request' && $cmd ne 'cancel' && $cmd ne 'approve' && $cmd ne 'reject');

	return $epp->_transfer_request($cmd, $type, $object, $authinfo, $period);
}

sub handle_clone {
	my ($type, $old, $new) = @_;

	if (lc($type) eq 'contact') {
		return handle_contact_clone($old, $new);

	} elsif (lc($type) eq 'domain') {
		return handle_contact_domain($old, $new);

	} else {
		error("Unsupported object type '$type'");

	}
}

sub handle_contact_clone {
	my ($old, $new) = @_;

	my $info = $epp->contact_info($old) || return;

	$info->{'id'} = $new;
	$info->{'authInfo'} = generate_authinfo();

	return $epp->create_contact($info);
}

sub handle_contact_domain {
	my ($old, $new) = @_;

	my $info = $epp->domain_info($old) || return;

	$info->{'name'} = $new;
	$info->{'authInfo'} = generate_authinfo();

	return $epp->create_domain($info);
}

sub generate_authinfo {
	my $authinfo;

	my @chars = ('a'..'z'), ('A'..'Z'), (0-9);
	$authinfo .= $chars[int(rand(scalar(@chars)))-1] while (length($authinfo) < 12);

	return $authinfo;
}

sub handle_delete {
	my ($type, $id) = @_;
	if ($type eq 'domain') {
		return $epp->delete_domain($id);

	} elsif ($type eq 'host') {
		return $epp->delete_host($id);

	} elsif ($type eq 'contact') {
		return $epp->delete_contact($id);

	} else {
		error("Unsupported object type '$type'");
		return undef;

	}
}

sub handle_renew {
	my ($domain, $period) = @_;
	$period = 1 if (!$period);

	my $info = $epp->domain_info($domain);
	return undef if (!$info);

	my ($date, undef) = split(/T/, $info->{'exDate'}, 2);

	return $epp->renew_domain({
		'name'		=> $domain,
		'period'	=> $period,
		'cur_exp_date'	=> $date,
	});
}

sub handle_create {
	my $type = lc(shift);

	if ($type eq 'host') {
		return create_host(@_);

	} else {
		return error("invalid type '%s'", $type);

	}
}

sub create_host {
	my $host = { 'name' => shift };

	if (scalar(@_) > 0) {
		$host->{'addrs'} = [];
		foreach my $addr (@_) {
			my $version = 'v'.($addr =~ /:/ ? 6 : 4);
			push(@{$host->{'addrs'}}, { 'ip' => $addr, 'version' => $version });
		}
	}
	return $epp->create_host($host);
}

sub note {
	my ($fmt, @args) = @_;
	my $msg = sprintf($fmt, @args);
	print $msg."\n";
}

sub error {
	my ($fmt, @args) = @_;
	note("Error: ".$fmt, @args);
}

sub fatal {
	my ($fmt, @args) = @_;
	note("Fatal Error: ".$fmt, @args);
	exit(1);
}

=pod

=head1 NAME

Pepper - A command line EPP client

=head1 DESCRIPTION

Pepper is a command-line client for the EPP protocol. It's written in Perl and uses the Net::EPP module.

=head1 USAGE

pepper [--host=HOST] [--port=PORT] [--timeout=TIMEOUT] [--user=USER] [--pass=PASS] [--exec=COMMAND]

=over

=item --host=HOST

Specify the host name to connect to.

=item --port=PORT

Specify the port. Defaults to 700.

=item --timeout=TIMEOUT

Specify the timeout. Defaults to 3.

=item --user=USER

Specify user ID.

=item --pass=PASS

Specify password.

=item --exec=COMMAND

Specify command to execute. May be used multiple times. See L<SYNTAX> for more details.

=back

=head1 SYNTAX

Once running, Pepper provides a simple command line interface. The available commands are listed below:

=over

=item host HOST

set hostname

=item port PORT

set port (defaults to 700)

=item ssl on|off

enable/disable SSL (defaults to on)

=item timeout TIMEOUT

set timeout (default 5 seconds)

=item id USER

set username

=item pw PASS

set password

=item connect

connect to server

=item login

log in

=item logout

log out

=item hello

retrieve greeting from server

=item poll req

request most recent poll message

=item poll ack ID

acknowledge message ID

=item check TYPE OBJECT

check availability of object (TYPE is one of domain, host, contact)

=item info TYPE OBJECT

retrieve object information (TYPE is one of domain, host, contact)

=item send FILE

send the contents of FILE

=item BEGIN

begin inputting a frame to send to the server, end with "END"

=item keepalive SECS

keep the session alive by pinging the server every SECS seconds. Use zero to cancel

=item transfer PARAMS

object transfer management (see below)

=item clone TYPE OLD NEW

clone a domain or contact object OLD into a new object identified by NEW

=item delete TYPE ID

delete an object

=item renew DOMAIN PERIOD

renew a domain (1 year by default)

=item create host PARAMS

create a host object (see below)

=item exit

quit the program (logging out if necessary)

=back

=head2 OBJECT TRANSFERS

Object transfers may be managed with the transfer command. Usage:

  transfer TYPE OBJECT CMD [AUTHINFO [PERIOD]]
  
where:

=over

=item TYPE

one of (domain, contact)

=item OBJECT

domain name or contact ID

=item CMD

one of (request, query, approve, reject, cancel)

=item AUTHINFO

authInfo code (used with request only)

=item PERIOD

additional validity period (used with domain request only)

=back

=head2 CREATING DOMAIN AND CONTACT OBJECTS

Domains and contacts can be created using the "clone" command.

=head2 CREATING HOST OBJECTS

Syntax:

  create host HOSTNAME [IP [IP [IP [...]]]]

Create a host object with the specified HOSTNAME. IP address may also be
specified: IPv4 and IPv6 addresses are automatically detected.

=head1 LICENSE

Copyright CentralNic Group plc.

This program is Free Software; you can use it and/or modify it under the same terms as Perl itself.

=cut