#!/usr/bin/perl
# Copyright CentralNic Group plc.
# This program is Free Software; you can use it and/or modify it under the same
# terms as Perl itself.
use Term::ReadLine;
use Net::EPP::Simple;
use Getopt::Long;
use Text::ParseWords;
use Data::Dumper;
use strict;

my $opt = {};
GetOptions($opt,
	'host=s',
	'user=s',
	'pass=s',
	'timeout=i',
	'help',
	'exec=s',
);

my $handlers = {
	'timeout'	=> \&handle_timeout,
	'ssl'		=> \&handle_ssl,
	'host'		=> \&handle_host,
	'port'		=> \&handle_port,
	'credentials'	=> \&handle_credentials,
	'connect'	=> \&handle_connect,
	'login'		=> \&handle_login,
	'logout'	=> \&handle_logout,
	'hello'		=> \&handle_hello,
	'check'		=> \&handle_check,
	'info'		=> \&handle_info,
	'poll'		=> \&handle_poll,
	'help'		=> \&handle_help,
	'send'		=> \&handle_send,
	'BEGIN'		=> \&handle_begin,
	'exit'		=> \&handle_exit,
	'keepalive'	=> \&handle_keepalive,
	'transfer'	=> \&handle_transfer,
	'clone'		=> \&handle_clone,
	'delete'	=> \&handle_delete,
	'renew'		=> \&handle_renew,
	'create'	=> \&handle_create,
};

if ($opt->{'help'}) {
	execute_command('help');
	exit;
}

my $epp = Net::EPP::Simple->new(
	'host'		=> '',
	'connect'	=> undef,
	'debug'		=> ($opt->{'exec'} eq ''),
	'login'		=> undef,
	'reconnect'	=> 0,
);


note('Welcome to pepper!');

execute_command(sprintf('timeout %d', $opt->{'timeout'})) if ($opt->{'timeout'});

if ($opt->{'host'}) {
	execute_command(sprintf('host "%s"', quotemeta($opt->{'host'})));
	execute_command('connect');
}

if ($opt->{'user'} ne '' && $opt->{'pass'} ne '') {
	execute_command(sprintf('credentials "%s" "%s"', quotemeta($opt->{'user'}), quotemeta($opt->{'pass'})));
	execute_command('login');
}

if ($opt->{'exec'} ne '') {
	if (!$epp->{'authenticated'}) {
		fatal('not logged in');

	} else {
		$epp->{'debug'} = 1;
		execute_command($opt->{'exec'});
		$epp->{'debug'} = 0;
		exit;

	}
}

my $term = Term::ReadLine->new('pepper');
my $prompt = 'pepper> ';
my $out = $term->OUT || \*STDOUT;

while (my $command = $term->readline($prompt)) {
	$term->addhistory($command);
	execute_command($command);
}

$epp->logout if ($epp->{'connected'} && $epp->{'authenticated'});
$epp->disconnect if ($epp->{'connected'});

note('bye!');

sub execute_command {
	my $line = shift;
	my @args = shellwords($line);
	my $command = shift(@args);

	if (!defined($handlers->{$command})) {
		error("Unknown command '$command'");

	} else {
		&{$handlers->{$command}}(@args);

	}
}

sub handle_timeout {
	$epp->{'timeout'} = int($_[0]);
	note("Timeout set to %ds", $_[0]);
	return 1;
}

sub handle_ssl {
	if ($_[0] eq 'on') {
		$epp->{'ssl'} = 1;
		note('SSL enabled');

	} elsif ($_[0] eq 'off') {
		$epp->{'ssl'} = undef;
		note('SSL disabled');

	} else {
		error("Invalid SSL mode '%s'", $_[0]);
		return undef;

	}
	return 1;
}

sub handle_host {
	$epp->{'host'} = $_[0];
	note("Host set to %s", $_[0]);
	return 1;
}

sub handle_port {
	$epp->{'port'} = int($_[0]);
	note("Port set to %d", $_[0]);
	return 1;
}

sub handle_connect {
	if ($epp->{'host'} eq '') {
		error('No host specified');
		return undef;

	} else {
		note('Connecting to %s', $epp->{'host'});
		return $epp->_connect(undef);

	}
}

sub handle_credentials {
	if ($_[0] eq '') {
		error('Missing client ID');
		return undef;

	} elsif ($_[1] eq '') {
		error('Missing password');
		return undef;

	} else {
		note('Setting credentials for client ID %s', $_[0]);
		$epp->{'user'} = $_[0];
		$epp->{'pass'} = $_[1];
		return 1;

	}
}

sub handle_login {
	if ($epp->{'host'} eq '') {
		error('No host specified');
		return undef;

	} elsif ($epp->{'user'} eq '' || $epp->{'pass'} eq '') {
		error('No credentials specified');
		return undef;

	} elsif (!defined($epp->{'connected'})) {
		return handle_connect() && handle_login();

	} else {
		return $epp->_login;

	}
}

sub handle_logout {
	if (!defined($epp->{'authenticated'})) {
		error('Not logged in');
		return undef;

	} else {
		note('logging out');
		return $epp->logout;
	}
}

sub handle_hello {
	return $epp->ping;
}

sub handle_check {
	my ($type, $id) = @_;
	if ($type eq 'domain') {
		return $epp->check_domain($id);

	} elsif ($type eq 'host') {
		return $epp->check_host($id);

	} elsif ($type eq 'contact') {
		return $epp->check_contact($id);

	} else {
		error("Unsupported object type '$type'");
		return undef;

	}
}

sub handle_info {
	my ($type, $id) = @_;
	if ($type eq 'domain') {
		return $epp->domain_info($id);

	} elsif ($type eq 'host') {
		return $epp->host_info($id);

	} elsif ($type eq 'contact') {
		return $epp->contact_info($id);

	} else {
		error("Unsupported object type '$type'");
		return undef;

	}
}

sub handle_poll {
	my ($op, $id) = @_;
	if ($op eq 'req') {
		my $frame = Net::EPP::Frame::Command::Poll::Req->new;
		$epp->request($frame);

	} elsif ($op eq 'ack') {
		my $frame = Net::EPP::Frame::Command::Poll::Ack->new;
		$frame->setMsgID($id);
		$epp->request($frame);

	} else {
		error("Unsupported poll op '$op'");

	}
}

sub handle_send {
	$epp->request($_[0]);
}

sub handle_begin {
	my $buffer = '';
	while (my $line = <STDIN>) {
		if ($line =~ /^END/) {
			last;

		} else {
			$buffer .= $line;

		}
	}
	$epp->request($buffer);
}

sub handle_help {
	print <<"END";
Available commands:

host HOST		- set hostname
port PORT		- set port (defaults to 700)
ssl on|off		- enable/disable SSL (defaults to on)
timeout TIMEOUT		- set timeout (default 5 seconds)
credentials USER PASS	- set login credentials
connect			- connect to server
login			- log in
logout			- log out
hello			- retrieve greeting from server
poll req		- request most recent poll message
poll ack ID		- acknowledge message ID
check TYPE OBJECT	- check availability of object (TYPE is one of
			  domain, host, contact)
info TYPE OBJECT	- retrieve object information (TYPE is one of
			  domain, host, contact)
send FILE		- send the contents of FILE
BEGIN			- begin inputting a frame to send to the server,
			  end with "END"
keepalive SECS		- keep the session alive by pinging the server every
			  SECS seconds. Use zero to cancel
transfer PARAMS		- object transfer management (see below)
clone TYPE OLD NEW	- clone a domain or contact object OLD into a new object
			  identified by NEW
delete TYPE ID		- delete an object
renew DOMAIN PERIOD	- renew a domain (1 year by default)
create host PARAMS	- create a host object (see below)
exit			- quit the program (logging out if necessary)

Object transfers:

Object transfers may be managed with the transfer command. Usage:

  transfer TYPE OBJECT CMD [AUTHINFO [PERIOD]]

where:

TYPE		- one of (domain, contact)
OBJECT		- domain name or contact ID
CMD		- one of (request, query, approve, reject, cancel)
AUTHINFO	- authInfo code (used with request only)
PERIOD		- additional validity period (used with domain request only)

Creating Host Objects

  create host HOSTNAME [IP [IP [IP [...]]]]

Create a host object with the specified HOSTNAME. IP address may also be
specified: IPv4 and IPv6 addresses are automatically detected.

Domains and contacts can be created using the "clone" command.

END
	return 1;
}

sub handle_keepalive {
	$epp->{'keepalive'} = int(shift);
	alarm(0);
	if ($epp->{'keepalive'} < 1) {
		note('disabling keepalive');
		undef($SIG{'ALRM'});

	} else {
		note('setting keepalive interval to %ds', $epp->{'keepalive'});
		$SIG{'ALRM'} = sub {
			note('ping');
			$epp->ping if ($epp->{'connected'});
			alarm($epp->{'keepalive'});
		};
		alarm($epp->{'keepalive'});
	}
}

sub handle_exit {
	$epp->logout if ($epp->{'authenticated'});
	$epp->disconnect if ($epp->{'connected'});
	note('bye!');
	exit;
}

sub handle_transfer {
	my ($type, $object, $cmd, $authinfo, $period) = @_;

	return error("invalid object type '%s'", $type) if ($type ne 'domain' && $type ne 'contact');
	return error("invalid command '%s'", $cmd) if ($cmd ne 'query' && $cmd ne 'request' && $cmd ne 'cancel' && $cmd ne 'approve' && $cmd ne 'reject');

	return $epp->_transfer_request($cmd, $type, $object, $authinfo, $period);
}

sub handle_clone {
	my ($type, $old, $new) = @_;

	if (lc($type) eq 'contact') {
		return handle_contact_clone($old, $new);

	} elsif (lc($type) eq 'domain') {
		return handle_contact_domain($old, $new);

	} else {
		error("Unsupported object type '$type'");

	}
}

sub handle_contact_clone {
	my ($old, $new) = @_;

	my $info = $epp->contact_info($old) || return;

	$info->{'id'} = $new;
	$info->{'authInfo'} = generate_authinfo();

	return $epp->create_contact($info);
}

sub handle_contact_domain {
	my ($old, $new) = @_;

	my $info = $epp->domain_info($old) || return;

	$info->{'name'} = $new;
	$info->{'authInfo'} = generate_authinfo();

	return $epp->create_domain($info);
}

sub generate_authinfo {
	my $authinfo;

	my @chars = ('a'..'z'), ('A'..'Z'), (0-9);
	$authinfo .= $chars[int(rand(scalar(@chars)))-1] while (length($authinfo) < 12);

	return $authinfo;
}

sub handle_delete {
	my ($type, $id) = @_;
	if ($type eq 'domain') {
		return $epp->delete_domain($id);

	} elsif ($type eq 'host') {
		return $epp->delete_host($id);

	} elsif ($type eq 'contact') {
		return $epp->delete_contact($id);

	} else {
		error("Unsupported object type '$type'");
		return undef;

	}
}

sub handle_renew {
	my ($domain, $period) = @_;
	$period = 1 if (!$period);

	my $info = $epp->domain_info($domain);
	return undef if (!$info);

	my ($date, undef) = split(/T/, $info->{'exDate'}, 2);

	return $epp->renew_domain({
		'name'		=> $domain,
		'period'	=> $period,
		'cur_exp_date'	=> $date,
	});
}

sub handle_create {
	my $type = lc(shift);

	if ($type eq 'host') {
		return create_host(@_);

	} else {
		return error("invalid type '%s'", $type);

	}
}

sub create_host {
	my $host = { 'name' => shift };

	if (scalar(@_) > 0) {
		$host->{'addrs'} = [];
		foreach my $addr (@_) {
			my $version = 'v'.($addr =~ /:/ ? 6 : 4);
			push(@{$host->{'addrs'}}, { 'ip' => $addr, 'version' => $version });
		}
	}
	return $epp->create_host($host);
}

sub note {
	my ($fmt, @args) = @_;
	my $msg = sprintf($fmt, @args);
	print $msg."\n";
}

sub error {
	my ($fmt, @args) = @_;
	note("Error: ".$fmt, @args);
}

sub fatal {
	my ($fmt, @args) = @_;
	note("Fatal Error: ".$fmt, @args);
	exit(1);
}