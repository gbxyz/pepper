#!/usr/bin/perl
# Copyright CentralNic Group plc.
# This program is Free Software; you can use it and/or modify it under the same
# terms as Perl itself.
package Pepper::EPPClient;
use base qw(Net::EPP::Simple);
use Data::Dumper;

sub new {
	my ($package, %params) = @_;

	my $self = $package->SUPER::new(%params);

	$self->{'outfh'} = $params{'outfh'};

	return $self;
}

sub get_frame {
	my $self = shift;
	my $response = $self->SUPER::get_frame;
	map { $self->{'outfh'}->print(sprintf("S: %s\n", $_)) } split(/\n/, $response->toString(2)) if (!$self->{'quiet'} && $response);
	return $response;
}

sub send_frame {
	my ($self, $frame, $wfcheck) = @_;

	map { $self->{'outfh'}->print(sprintf("C: %s\n", $_)) } split(/\n/, $frame->isa('XML::LibXML::Document') ? $frame->toString(2) : $frame) unless ($self->{'quiet'});;

	return $self->SUPER::send_frame($frame, $wfcheck);
}

sub request {
	my ($self, $frame) = @_;

	my $response = $self->SUPER::request($frame);

	if (!$response) {
		$self->{'outfh'}->print(sprintf("%04d %s\n", $Net::EPP::Simple::Code, $Net::EPP::Simple::Error));

	} else {
		return $response;

	}
}

package main;
use Term::ReadLine;
use Net::EPP::Simple;
use Getopt::Long;
use Text::ParseWords;
use Pod::Usage;
use File::Temp qw(tmpnam);
use Mozilla::CA;
use strict;

my $opt = {
	'port'		=> 700,
	'timeout'	=> 15,
	'lang'		=> 'en',
};

GetOptions($opt,
	'host=s',
	'user=s',
	'pass=s',
	'port=i',
	'timeout=i',
	'help',
	'exec=s',
	'insecure',
	'lang=s',
	'debug',
);

my $handlers = {
	'timeout'	=> \&handle_timeout,
	'ssl'		=> \&handle_ssl,
	'host'		=> \&handle_host,
	'port'		=> \&handle_port,
	'credentials'	=> \&handle_credentials,
	'id'		=> \&handle_id,
	'pw'		=> \&handle_pw,
	'connect'	=> \&handle_connect,
	'login'		=> \&handle_login,
	'logout'	=> \&handle_logout,
	'hello'		=> \&handle_hello,
	'check'		=> \&handle_check,
	'info'		=> \&handle_info,
	'poll'		=> \&handle_poll,
	'help'		=> \&handle_help,
	'send'		=> \&handle_send,
	'BEGIN'		=> \&handle_begin,
	'exit'		=> \&handle_exit,
	'transfer'	=> \&handle_transfer,
	'clone'		=> \&handle_clone,
	'delete'	=> \&handle_delete,
	'renew'		=> \&handle_renew,
	'create'	=> \&handle_create,
	'edit'		=> \&handle_edit,
	'cert'		=> \&handle_cert,
	'key'		=> \&handle_key,
	'restore'	=> \&handle_restore,
	'update'	=> \&handle_update,
};

if ($opt->{'help'}) {
	execute_command('help USAGE');
	exit;
}

my $term = Term::ReadLine->new('pepper');
my $prompt = 'pepper> ';
my $out = $term->OUT || \*STDOUT;

my $histfile = $ENV{'HOME'}.'/.pepper_history';

$term->ReadHistory($histfile);

note('Welcome to pepper!');

note('For best results, install Term::ReadLine::Gnu') if ('Term::ReadLine::Gnu' ne $term->ReadLine);

my $epp = Pepper::EPPClient->new(
	'host'		=> '',
	'connect'	=> undef,
	'debug'		=> $opt->{'debug'},
	'login'		=> undef,
	'reconnect'	=> 0,
	'verify'	=> ($opt->{'insecure'} ? undef : 1),
	'ca_file'	=> Mozilla::CA::SSL_ca_file(),
	'lang'		=> ($opt->{'lang'} ? $opt->{'lang'} : 'en'),
	'outfh'		=> $out,
);

execute_command(sprintf('timeout %d',	$opt->{'timeout'}))	if ($opt->{'timeout'});
execute_command(sprintf('port %d',	$opt->{'port'}))	if ($opt->{'port'});
execute_command(sprintf('host %s',	$opt->{'host'}))	if ($opt->{'host'});
execute_command(sprintf('id %s',	$opt->{'user'}))	if ($opt->{'user'});
execute_command(sprintf('pw %s',	$opt->{'pass'}))	if ($opt->{'pass'});

if ($epp->{'user'} ne '' && $epp->{'pass'} ne '') {
	execute_command('login');

} elsif ($epp->{'host'} ne '') {
	execute_command('connect');

}

if ($opt->{'exec'} ne '') {
	if (!$epp->authenticated) {
		fatal('not logged in');

	} else {
		execute_command($opt->{'exec'});
		exit;

	}
}

my $last;
while (1) {
	my $command = $term->readline($prompt);
	alarm(0);
	if (!defined($command)) {
		last;

	} elsif ($command ne '') {
		if ($command eq '!!') {
			execute_command($last) if ($last ne '');

		} else {
			$last = $command;
			execute_command($command);

		}

	}
}

$term->WriteHistory($histfile);

$epp->logout if ($epp->connected && $epp->authenticated);
$epp->disconnect if ($epp->connected);

note('bye!');

sub execute_command {
	my $line = shift;
	return if ($line eq '');

	my @args = shellwords($line);
	my $command = shift(@args);

	if (!defined($handlers->{$command})) {
		error("Unknown command '$command'");

	} else {
		&{$handlers->{$command}}(@args);

	}
}

sub handle_timeout {
	$epp->{'timeout'} = int($_[0]);
	note("Timeout set to %ds", $_[0]);
	return 1;
}

sub handle_ssl {
	if ($_[0] eq 'on') {
		$epp->{'ssl'} = 1;
		note('SSL enabled');

	} elsif ($_[0] eq 'off') {
		$epp->{'ssl'} = undef;
		note('SSL disabled');

	} else {
		return error("Invalid SSL mode '%s'", $_[0]);

	}
	return 1;
}

sub handle_host {
	$epp->{'host'} = $_[0];
	note("Host set to %s", $_[0]);
	return 1;
}

sub handle_port {
	$epp->{'port'} = int($_[0]);
	note("Port set to %d", $_[0]);
	return 1;
}

sub handle_connect {
	if ($epp->{'host'} eq '') {
		return error('No host specified');

	} else {
		note('Connecting to %s', $epp->{'host'});

		$epp->{'quiet'} = 1;
		my $result = $epp->_connect(undef);
		$epp->{'quiet'} = 0;

		if ($result) {
			note("Connected OK. Type 'hello' to see the greeting frame.");

		} else {
			error("Unable to connect: %s", $Net::EPP::Simple::Message);

		}
		return $result;
	}
}

sub handle_credentials {
	if ($_[0] eq '') {
		return error('Missing client ID');

	} elsif ($_[1] eq '') {
		return error('Missing password');

	} else {
		handle_id($_[0]);
		handle_pw($_[1]);
		return 1;

	}
}

sub handle_id {
	$epp->{'user'} = shift;
	note("User ID set to '%s'", $epp->{'user'});
}

sub handle_pw {
	$epp->{'pass'} = shift;
	note("Password set to '%s'", ('*' x length($epp->{'pass'})));
}

sub handle_login {
	my $verbose = shift;
	if ($epp->{'host'} eq '') {
		return error('No host specified');

	} elsif ($epp->{'user'} eq '' || $epp->{'pass'} eq '') {
		return error('No credentials specified');

	} elsif (!$epp->connected) {
		return handle_connect() && handle_login();

	} elsif ($epp->authenticated) {
		return error('Already logged in');

	} else {
		$epp->{'quiet'} = ($verbose ? 0 : 1);
		my $result = $epp->_login;
		$epp->{'quiet'} = 0;
		note("%04d %s", $Net::EPP::Simple::Code, $Net::EPP::Simple::Message);
		return $result;

	}
}

sub handle_logout {
	if (!$epp->authenticated) {
		return error('Not logged in');

	} else {
		note('logging out');
		$epp->{'quiet'} = 1;
		my $result = $epp->logout;
		$epp->{'quiet'} = 0;
		note("%04d %s", $Net::EPP::Simple::Code, $Net::EPP::Simple::Message);
		return $result;
	}
}

sub handle_hello {
	return $epp->ping;
}

sub handle_check {
	my ($type, $id, @extra) = @_;
	if ($type eq 'domain') {
		return $epp->check_domain($id);

	} elsif ($type eq 'claims') {
		return handle_claims_check($id);

	} elsif ($type eq 'fee') {
		return handle_fee_check($id, @extra);

	} elsif ($type eq 'host') {
		return $epp->check_host($id);

	} elsif ($type eq 'contact') {
		return $epp->check_contact($id);

	} else {
		return error("Unsupported object type '$type'");

	}
}

sub handle_claims_check {
	my $domain = shift;
	my $frame = Net::EPP::Frame::Command::Check::Domain->new;
	$frame->addDomain($domain);

	my $launch_ns = 'urn:ietf:params:xml:ns:launch-1.0';

	my $phase = $frame->createElementNS($launch_ns, 'phase');
	$phase->appendChild($frame->createTextNode('claims'));

	my $launch = $frame->createElementNS($launch_ns, 'check');
	$launch->setAttribute('type', 'claims');
	$launch->appendChild($phase);

	my $extn = $frame->createElement('extension');
	$extn->appendChild($launch);

	$frame->clTRID->parentNode->insertBefore($extn, $frame->clTRID);

	return $epp->request($frame);
}

sub handle_fee_check {
	my %params;
	($params{'name'}, $params{'command'}, $params{'currency'}, $params{'period'}) = @_;

	my $domain = shift;
	my $frame = Net::EPP::Frame::Command::Check::Domain->new;
	$frame->addDomain($params{'name'});

	my $fee_ns = 'urn:ietf:params:xml:ns:fee-0.5';
	my $ok = undef;
	foreach my $el ($epp->greeting->getElementsByTagName('extURI')) {
		$ok = 1 if ($el->textContent eq $fee_ns);
	}

	return error("Server does not support the version of the fee extension that I support!") if (!$ok);

	my $domain = $frame->createElementNS($fee_ns, 'domain');
	foreach my $name (qw(name currency command period)) {
		next if ($params{$name} eq '');
		my $el = $frame->createElementNS($fee_ns, $name);
		$el->appendChild($frame->createTextNode($params{$name}));
		$el->setAttribute('unit', 'y') if ('period' eq $name);
		$domain->appendChild($el);
	}

	my $check = $frame->createElementNS($fee_ns, 'check');
	$check->appendChild($domain);

	my $extn = $frame->createElement('extension');
	$extn->appendChild($check);

	$frame->clTRID->parentNode->insertBefore($extn, $frame->clTRID);

	return $epp->request($frame);
}

sub handle_info {
	my ($type, $id, $authInfo, $opt) = @_;
	if ($type eq 'domain') {
		$opt = $opt || 'all';
		return $epp->domain_info($id, $authInfo, undef, $opt);

	} elsif ($type eq 'host') {
		return $epp->host_info($id);

	} elsif ($type eq 'contact') {
		return $epp->contact_info($id, $authInfo, $opt);

	} else {
		return error("Unsupported object type '$type'");

	}
}

sub handle_poll {
	my ($op, $id) = @_;
	if ($op eq 'req') {
		my $frame = Net::EPP::Frame::Command::Poll::Req->new;
		$epp->request($frame);

	} elsif ($op eq 'ack') {
		my $frame = Net::EPP::Frame::Command::Poll::Ack->new;
		$frame->setMsgID($id);
		$epp->request($frame);

	} else {
		error("Unsupported poll op '$op'");

	}
}

sub handle_send {
	$epp->request($_[0]);
}

sub handle_begin {
	my $buffer = '';
	while (my $line = <STDIN>) {
		if ($line =~ /^END/) {
			last;

		} else {
			$buffer .= $line;

		}
	}
	$epp->request($buffer);
}

sub handle_help {
	pod2usage(
		'-verbose'	=> 99,
		'-sections'	=> join('|', @_) || 'SYNTAX',
		'-exitval'	=> 'NOEXIT',
	);
}

sub handle_exit {
	$epp->logout if ($epp->authenticated);
	$epp->disconnect if ($epp->connected);
	note('bye!');
	exit;
}

sub handle_transfer {
	my ($type, $object, $cmd, $authinfo, $period) = @_;

	return error("invalid object type '%s'", $type) if ($type ne 'domain' && $type ne 'contact');
	return error("invalid command '%s'", $cmd) if ($cmd ne 'query' && $cmd ne 'request' && $cmd ne 'cancel' && $cmd ne 'approve' && $cmd ne 'reject');

	return $epp->_transfer_request($cmd, $type, $object, $authinfo, $period);
}

sub handle_clone {
	my ($type, $old, $new) = @_;

	if (lc($type) eq 'contact') {
		return handle_contact_clone($old, $new);

	} elsif (lc($type) eq 'domain') {
		return handle_domain_clone($old, $new);

	} else {
		error("Unsupported object type '$type'");

	}
}

sub handle_contact_clone {
	my ($old, $new) = @_;

	my $info = $epp->contact_info($old) || return;

	$info->{'id'} = $new;
	$info->{'authInfo'} = generate_authinfo();

	return $epp->create_contact($info);
}

sub handle_domain_clone {
	my ($old, $new) = @_;

	my $info = $epp->domain_info($old) || return;

	$info->{'name'} = $new;
	$info->{'authInfo'} = generate_authinfo();

	return $epp->create_domain($info);
}

sub generate_authinfo {
	my $authinfo;

	my @chars = ('a'..'z'), ('A'..'Z'), (0-9);
	$authinfo .= $chars[int(rand(scalar(@chars)))-1] while (length($authinfo) < 12);

	return $authinfo;
}

sub handle_delete {
	my ($type, $id) = @_;
	if ($type eq 'domain') {
		return $epp->delete_domain($id);

	} elsif ($type eq 'host') {
		return $epp->delete_host($id);

	} elsif ($type eq 'contact') {
		return $epp->delete_contact($id);

	} else {
		return error("Unsupported object type '$type'");

	}
}

sub handle_renew {
	my ($domain, $period) = @_;
	$period = 1 if (!$period);

	my $info = $epp->domain_info($domain);
	return undef if (!$info);

	my ($date, undef) = split(/T/, $info->{'exDate'}, 2);

	return $epp->renew_domain({
		'name'		=> $domain,
		'period'	=> $period,
		'cur_exp_date'	=> $date,
	});
}

sub handle_create {
	my $type = lc(shift);

	if ($type eq 'host') {
		return create_host(@_);

	} else {
		return error("invalid type '%s'", $type);

	}
}

sub create_host {
	my $host = { 'name' => shift };

	if (scalar(@_) > 0) {
		$host->{'addrs'} = [];
		foreach my $addr (@_) {
			my $version = 'v'.($addr =~ /:/ ? 6 : 4);
			push(@{$host->{'addrs'}}, { 'ip' => $addr, 'version' => $version });
		}
	}
	return $epp->create_host($host);
}

sub handle_edit {
	my $file = tmpnam();
	if (0 != system(sprintf("%s %s", $ENV{'EDITOR'}, quotemeta($file)))) {
		error("$ENV{'EDITOR'} exited abnormally");

	} else {
		if (!-e $file || 0 == (stat($file))[7]) {
			note("no data to send");

		} else {
			local $/ = undef;
			open(FILE, $file);
			my $frame = <FILE>;
			close(FILE);
			unlink($file);
			$epp->request($frame);
		}
	}
}

sub handle_key {
	my ($key, $pass) = @_;
	$epp->{'key'} = $key;
	$epp->{'passphrase'} = $pass;
	note("Using '$key' as private key");
}

sub handle_cert {
	my $cert = shift;
	$epp->{'cert'} = $cert;
	note("Using '$cert' as certificate");
}

sub handle_restore {
	my $domain = shift;

	my $frame = Net::EPP::Frame::Command::Update::Domain->new;
	$frame->setDomain($domain);

	my $ext = $frame->getNode('extension');
	if (!defined($ext)) {
		$ext = $frame->createElementNS(undef, 'extension');
		$frame->getNode('command')->insertBefore($ext, $frame->clTRID);
	}

	my $RGP_URN = 'urn:ietf:params:xml:ns:rgp-1.0';

	my $upd = $ext->addNewChild($RGP_URN, 'rgp:update');
	my $restore = $upd->addNewChild($RGP_URN, 'rgp:restore');
	$restore->setAttribute('op', 'request');

	return $epp->request($frame);
}

sub handle_update {
	my $type = shift;
	if ($type eq 'domain') {
		return domain_update(@_);

	} elsif ($type eq 'host') {
		return host_update(@_);

	} elsif ($type eq 'contact') {
		return contact_update(@_);

	} else {
		return error("Unsupported object type '$type'");

	}
}

sub domain_update {
	error("Domain update not supported yet");
}

sub host_update {
	my $frame = Net::EPP::Frame::Command::Update::Host->new;

	$frame->setHost(shift(@_));

	my $changes = {
		'addr' => [],
		'status' => [],
	};

	for (my $i = 0 ; $i < scalar(@_) ; $i++) {
		my $action	= lc($_[$i]);
		my $type	= lc($_[++$i]);
		my $value	= $_[++$i];

		return error("Invalid parameter '$action'") if ($action !~ /^(add|rem|chg)$/);
		return error("Missing parameter") if (!$type || !$value);
		return error("Invalid property '$type'") if ($type !~ /^(addr|status|name)$/);

		if ($type eq 'addr') {
			push(@{$changes->{'addr'}}, [ $action,  $value ]);

		} elsif ($type eq 'status') {
			push(@{$changes->{'status'}}, [ $action,  $value ]);

		} elsif ($action eq 'chg') {
			if ($type ne 'name') {
				return error("You can only change the host name");

			} else {
				$frame->chgName($value);

			}
		}
	}

	# we need to add <addr> elements first
	foreach my $change (@{$changes->{'addr'}}) {
		my ($action, $value) = @{$change};
		if ($action eq 'add') {
			$frame->addAddr({'ip' => $value, 'version' => ($value =~ /:/ ? 'v6' : 'v4') });

		} else {
			$frame->remAddr({'ip' => $value, 'version' => ($value =~ /:/ ? 'v6' : 'v4') });

		}
	}

	# we need to add <status> elements second
	foreach my $change (@{$changes->{'status'}}) {
		my ($action, $value) = @{$change};
		if ($action eq 'add') {
			$frame->addStatus($value);

		} else {
			$frame->remStatus($value);

		}
	}

	return $epp->request($frame);
}

sub contact_update {
	error("Contact update not supported yet");
}

sub note {
	my ($fmt, @args) = @_;
	my $msg = sprintf($fmt, @args);
	print $out $msg."\n";
}

sub error {
	my ($fmt, @args) = @_;
	note("Error: ".$fmt, @args);
	return undef;
}

sub fatal {
	my ($fmt, @args) = @_;
	note("Fatal Error: ".$fmt, @args);
	exit(1);
}

=pod

=head1 NAME

Pepper - A command line EPP client

=head1 DESCRIPTION

Pepper is a command-line client for the EPP protocol. It's written in Perl and uses the Net::EPP module.

=head1 USAGE

	pepper [--host=HOST] [--port=PORT] [--timeout=TIMEOUT] [--user=USER] [--pass=PASS] [--exec=COMMAND]

=over

=item C<--host=HOST>

Specify the host name to connect to.

=item C<--port=PORT>

Specify the port. Defaults to 700.

=item C<--timeout=TIMEOUT>

Specify the timeout. Defaults to 3.

=item C<--user=USER>

Specify user ID.

=item C<--pass=PASS>

Specify password.

=item C<--exec=COMMAND>

Specify command to execute. May be used multiple times. See L<SYNTAX> for more details.

=item C<--insecure>

Disable SSL certificate checks.

=item C<--lang=LANG>

Specify language.

=back

=head1 SYNTAX

Once running, Pepper provides a simple command line interface. The available commands are listed below:

=over

=item C<help>

display manual

=item C<host HOST>

set hostname

=item C<port PORT>

set port (defaults to 700)

=item C<ssl on|off>

enable/disable SSL (defaults to on)

=item C<timeout TIMEOUT>

set timeout (default 5 seconds)

=item C<id USER>

set username

=item C<pw PASS>

set password

=item C<connect>

connect to server

=item C<login>

log in

=item C<logout>

log out

=item C<hello>

retrieve greeting from server

=item C<poll req>

request most recent poll message

=item C<poll ack ID>

acknowledge message C<ID>

=item C<check TYPE OBJECT>

check availability of object (C<TYPE> is one of C<domain>, C<host>, C<contact>, C<claims>, C<fee>). See L<CLAIMS AND FEE CHECKS> for more information about the latter two.

=item C<info TYPE OBJECT>

retrieve object information (C<TYPE> is one of C<domain>, C<host>, C<contact>)

=item C<send FILE>

send the contents of C<FILE>

=item C<BEGIN>

begin inputting a frame to send to the server, end with "C<END>"

=item C<edit>

Invoke C<$EDITOR> and send the resulting file

=item C<transfer PARAMS>

object transfer management See L<OBJECT TRANSFERS> for more information.

=item C<clone TYPE OLD NEW>

clone a domain or contact object C<OLD> into a new object identified by C<NEW> (C<TYPE> is one of C<domain>, C<contact>)

=item C<delete TYPE ID>

delete an object (C<TYPE> is one of C<domain>, C<host>, C<contact>)

=item C<renew DOMAIN PERIOD>

renew a domain (1 year by default)

=item C<restore DOMAIN>

submit an RGP restore request for a domain

=item C<create host PARAMS>

create a host object. See L<CREATING HOST OBJECTS> for more information.

=item C<exit>

quit the program (logging out if necessary)

=back

=head2 OBJECT UPDATES

Objects may be updated using the C<update> command.

=head3 Host updates

Syntax:

  update host HOSTNAME CHANGES

The C<CHANGES> argument consists of groups of three values: an action (ie C<add>, C<rem> or C<chg>) followed by a property name (ie C<addr>, C<status> or C<name>) followed by a value.

Examples:

  update ns0.example.com add status clientUpdateProhibited

  update ns0.example.com rem addr 10.0.0.1

  update ns0.example.com chg name ns0.example.net

Multiple changes can be combined in a single command:

  update host ns0.example.com add status clientUpdateProhibited rem addr 10.0.0.1 add addr 1::1 chg name ns0.example.net

=head3 Domain and Contact updates

Not currently implemented.

=head2 OBJECT TRANSFERS

Object transfers may be managed with the C<transfer> command. Usage:

  transfer TYPE OBJECT CMD [AUTHINFO [PERIOD]]
  
where:

=over

=item C<TYPE>

one of C<domain>, C<contact>

=item C<OBJECT>

domain name or contact ID

=item C<CMD>

one of (C<request>, C<query>, C<approve>, C<reject>, C<cancel>)

=item C<AUTHINFO>

authInfo code (used with C<request> only)

=item C<PERIOD>

additional validity period (used with domain C<request> only)

=back

=head2 CLAIMS AND FEE CHECKS

Pepper provides limited support for the the launch and fee extensions:

=head3 CLAIMS CHECK

The following command will extend the standard E<lt>checkE<gt> command to perform
a claims check as per Section 3.1.1. of L<draft-ietf-eppext-launchphase>.

	pepper> check claims example.xyz

=head3 FEE CHECK

The following command will extend the standard E<lt>checkE<gt> command to perform
a fee check as per Section 3.1.1. of L<draft-brown-epp-fees-02>.

	pepper> check fee example.xyz COMMAND [CURRENCY [PERIOD]]

C<COMMAND> must be one of: C<create>, C<renew>, C<transfer>, C<restore>.
C<CURRENCY> is OPTIONAL but if provided, must be a three-character currency code.
C<PERIOD> is also OPTIONAL but if provided, must be an integer between 1 and 99.

=head2 CREATING DOMAIN AND CONTACT OBJECTS

Domains and contacts can be created using the C<clone> command.

=head2 CREATING HOST OBJECTS

Syntax:

  create host HOSTNAME [IP [IP [IP [...]]]]

Create a host object with the specified C<HOSTNAME>. IP address may also be
specified: IPv4 and IPv6 addresses are automatically detected.

=head1 INSTALLATION

Pepper requires that the following Perl modules be installed:

=over

=item C<Term::ReadLine::Gnu> (and C<Term::ReadLine>)

=item C<Net::EPP::Simple> (from C<Net::EPP>, in turn requires C<IO::Socket::SSL> and C<XML::LibXML>)

=item C<Text::ParseWords>

=item C<Mozilla::CA>

=back

This can be installed using one of the various CPAN clients, or as packages from your operating system vendor.

=head1 LICENSE

Copyright CentralNic Group plc.

This program is Free Software; you can use it and/or modify it under the same terms as Perl itself.

=cut